циклы while

while a > N:
однократное выполнение цикла - итерация

pass_tru = 'password'
while ps != pass_tru:
    ps = input('введите пароль')

print('вход в систему)

есть операторы в цикле break, continue, и внешний else
break -по сути аварийный выход из цикла
continue пропуск одной итерации цикла и далее цикл идет на новую ветвь и штатно работает
else посел цикла пишется , но не обящателен, он сработает если цикл штатно завершился (по условию) если по ошибке или по break То это не получится проскочит
ELSE в цикле выполняется если цикл прошел все итерации Штатно, не натыкаясь на BREAK и на ERRROR
групповое введение на каждой строоке
import sys

# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))


НЕ зАБЫВАЕМ ПРО то что СПИСКИ и СТРОКИ ЕСТЬ ОПЕРАТОР IN ТЕ, СОЖЕРЖИТ, А не только find

Цикл for  используется для итерации любых итерируемых объектов (списки пр., строки)
Если нам нужно перебирать цифровую последовательость , то существует специальная функция range

for i in range(start, stop, step)  по умолчанию идет старт от 0 , стоп указываем (но он не включается в итерацию) и степ 1.
если перебрать нужно весь список то проще всего for i in range(len(spisok))
можно иетрирвать в любцю сторону range(-1, -10, -1) будет от -1 до -9
range(-10, -1, 1) от -10 до -2
range(-10, -5, -2)   [] т.к. идем от -10 с шагом -2 , а это противоположная сторона
range(-5)  []  т.к. идем от 0 с шагом 1 , а это противоположная сторона

Чтобы замениь значения в списке , не получится из поменять как
for i in spisok:
    i = 2
    мы так именно значение i только опменяем. а не знаения в списке, если нужном енять именно в списке нужно генерить
    последовательность и менять по идексно
for i in range(len(a)):
    a[i] = 2


печать послеовательности 
print(*range(11))
_______________________
a = map(int, input().split())
s = 0
for i in a:
    if i%2:
        s+=i
print(s)   
==================
print(sum([i for i in map(int,input().split()) if i % 2 != 0])) это равно верхнему

Если нужно брать последние буквы и сравнивать их с первыми в следующих словах, а есть исключения, типа Ъ, проще всего делать rstrip элемнтам, и удалть последние символы
или прямо при вводк резать
data = input().lower().split()
result = 'ДА'
for i in range(1, len(data)):
    if data[i][0] != data[i - 1].rstrip("ьъы")[-1]:
        result = 'НЕТ'
print(result)

print(sum([x for x in range(1, n) if x % 3 == 0 or x % 5 == 0]))  сумма чисел, делящихся на 5 или 3

print(sum(i if i % 3 == 0 or i % 5 == 0 else 0 for i in range(int(input()))))

Если мы выводим  список в виде троки через цикл for
s = ''
fl_first = True
for i in words:
    s *=('' if fl_first else  ' ') + W
    Fl_first = False

print(s)

либо можно при выводе ееще выбоать  print(s.lstrip) тогда пробелы образовавшиеся при выводе изаз конкотинации уберуться

Либо еще пролще соединяем все через join
print(' '.join(words))

Функция enumerate 
если мы работаем со списком нам часто нужно , одновременно и индек и значение, проще всего забрать это разом этой функцией
digs = [4, 3, 5, 10, 30, -30]
for i, d in enumerate(digs):
    if 10 <= abs(d) <= 99:
        digs[i] = 0

тут мы все 2-у значкные числа в списке заменяе  на 0, при этом сразу дергаем и данные числа d и сразу его индекс i        
 abs нам позволяет не обращать на отритцательнсть внимание

 Задача замена русских букв на латиницу
 t = ['a', 'b', 'v', 'g'......]
 start_index = ord ('a') тут мы вычисляем код по таблице символов ПК
 title = 'Программиров....'
 slug = ''

 for s in title.lower():   преобразуем к низу и читаем
    if 'а' <= s <= 'я':  смотрим что это буква русского алфавита, она от а до я
        slug += t[ord(s) - start_index] само преобразование,  мы берем  код из таблици символов от буквы которую берем в цикле, и вычитаем из нее код буквы А в итоге мы знаем на сколько эта буква удале на от А и знаем сколько вычесть чтобы по пасть в нашу таблицу на этот символ , ну и добавляем ее к текущей строке
    elif s == 'ё'  если встречаем Ё то меняем на yo    
        slug += 'yo'
    elif s == ' !?;:.,':  тут елси встречаются пробелы или символы мы заменяем на дефис
        slug += '-'
    else:
        slug +=s  это если чтото левое встертится, то остаалдяем как есть

while slug.count('--'):  проверям на тире после обработки и если есть двойные то меням их
    slug =     slug.replace('--', '-')   
print(slug)    

n = input()
c = []

for i, j in enumerate(n[:-1]):  так можно enumerate не до конца сделать
    if j+n[i+1] == "ра":
        c += [i]
 
print(*([-1], c)[len(c)>0])

В python есть функции типа iter, которой если передать итерируемый объетк, получим итератор (например итератор списка)
если итератор сохранить в переменную, получится однократный итератор, которым можно пройтись по объету 1 раз
далее используем функцию next() которой передаем как раз итератор
a = [4, 5, 6, 10]
it = iter(a)
next(it)
4
пссле каждого выхова она будет возвращать каждый раз следующий объект из нашего итерируемого спсика,  когда дошли до конца, возвращается stopiteration
вернуть в начало не возможно, если нужно снова , то нужно вновь через iter создать итератор
доступ по индексу и итерированипе это разные вещи. 
Также итерировать можно объекты, у которых вообще нет индексов, Напрмиер функция range()  от числв, нет индексов, но можно проитерировать
r = range(5)
r
range(0, 5)
it = iter(r)
next(it)
----
Важно не путать понятие итератора и итерируемого объекта. Для итерируемого объекта определен метод __iter__(), который позволяет превратить его в итератор, для которого, в свою очередь, определен метод __next__(), позволяющий пройти по итератору 1 раз, исчерпав его. На собесах любят вопрос: Является ли range() итератором? Ответ: нет, но из range() можно получить итератор, с помощью iter()
----
Цикл For как раз и перебирает итерируемые объекты с помощью механизма итераторов, он не явно вызывает функцию iter() и next() и итерирует, как доходит до stop iteration так заканчивается итерирвоание объекта.
В python не все объеты являются итерируемые, напрмиер число не итерируемо, но можно перебрать если [5] это прсотой список, или с помощью range(5) это уже полностью проитерируется от 0 до 5
Перебор и вывод 2-х первых объектов в столбик
print(*iter(input().split()[0:2]),sep='\n')

Если передать в next() второй аругмент , то вернется именно он вметсо ошибки при конце итерации
next(it, .)  при окончании не stop iteration будет а .

# put your python code here
print(*input())

# ну напишем iter )) хотя и в этой строчке он лишний
# [print(i, end=' ') for i in iter(input())]

Вложенные циклы:
посдедовательность 2-х и более циклов, могут быть одинаковые могут разные, не рекомендуется более чем 3 уровня вложенности.
применяется для обхода 2-у мерных списков, сложения сложных списков, инверсии списков.
1 1     1 2
2 2     3 4
a = ([1, 1], [2, 2])
b = ([1, 2], [3, 4])
c = []
for i, row in enumerate(a):
    r = []   - сдесь будут формироваться вложенные списки после суммирования
    for j, x in enumerate(row):
        r.append(x + b[i][j])   формируем влоденный список сложение Х это элемент строки 1-го списка и b[i][j]  -b иуи i-й влоденный список, j-й элемент в этом списке
    c.append(r)    добавляем в спсиок С готовый вложенный списов r
----
нужно перебрать и убрать лишние пробелы в твком вот спсике из строк
t = ["- Скажи-ка,  дядя, ведь не даром",
     "Я Python выучил с   каналом,",
     "Балакирев что    раздавал?",
     "Ведь были  ж схватки боевые,",
     "Да, говорят,   еще какие!",
     "Недаром помнит    вся Россия",
     "Как мы рубили   их тогда!"]
for i, line in enumerate(t):
    while line.count('  ') делаем вложенный цикл пока находим внтури двойные пробелы,  он бубет возвращать количество вхождений, если он вернет 0, то получится что это лож и цикл прекратится
        line = line.replace('  ', ' ')  меняем ближайшие 2-а пробела на 1-н пробел.
    t[i] = line    - во вложенный список вколадываем преобраованную строку.
print(t)


Создание матрицы по параметрам, тут создание матрицы из нулей
M,N = list(map(int, input("Введите M и N").split()))
zeros = []
for i in range(M):
    zeros.append([0] *N)


Замена 1-и 

for i in range(M):
     for j in range(N):
        zeros[i][j] = 1

транспорирование матриц, тут мы строки заменячем на столбцы т.е  было 1,2,3,4  теперь 1,5,9,13 и т.д. центральную строку можно не трогать она останется общей , это сократит количество циклов

image.png
a = ([1,2,3,4], [5,6,7,8],[9,10,11,12], [13,14,15,16]) #нужно поменять значения относительно диагонали, при этом нужно понимать, что середину можно нет рогать т.к. она не изменится
for i in range(len(a)):
    for j in range(i+1, len(a)): --- i+1 позволяет уменьшить количество циклов проходов, т.к. i На второй строке уже 1 и далее 2 это нам дает , сразу перебирать справа от диагонали, не трогая главную диагональ
        a[i][j], a[j][i] = a[j][i], a[i][j] #меняем местами , через множественное присваивание, вокруг главной диагонали.
#вывод
for r in a:
    for x in r:
        print(x, end = '\t')
    print()    


Создание матрицы размеро N
забитие ее 1
и далее меням посление 1 на 5
и выволим в виде матрицы
a = int(input())
b = []
for i in range(a):
    c = []
    for j in range(a):
        c.append(1)
    b.append(c)    
#print(b)   
for d,f in enumerate(b):
    b[d][-1]=5
    
for x in b:
    for y in x:
        print(y, end=' ')    
    print()
-------------------
тоже самое но вывод проще
a = int(input())
b = []
for i in range(a):
    c = []
    for j in range(a):
        c.append(1)
    b.append(c)    
#print(b)   
for d,f in enumerate(b):
    b[d][-1]=5
    
for x in b:
    print(*x)
----------    -----   так еще короче 
n = int(input())
a = [[1] * n for __ in range(n)]
for i in a:
  i[-1] = 5
[print(*i) for i in a]
-------------------    а так супер кортко
a = int(input())
g = []
for i in range(a):
    g.append([1]*(a))
    g[i][-1] = 5
    print(*g[i])

    ------
    ввод строки Ю ее очитска от любых пробелов и вывод через -
    import sys

# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))

for i in lst_in:
    print('-'.join(i.split()))  split убирает все пробелы в лббом количестве по умолчанию, если в скобках указать один пробел то будет убирать один

************
СОРТИРОВКА ВЫБОРОМ
a = list(map(int, input().split()))
for i in range(len(a[:-1])):
    min_ind = a.index(min(a[i+1:]), i+1)
    if a[i] > a[min_ind]:

        a[i], a[min_ind] = a[min_ind], a[i]
    
print(*a)



Треугольник Паскаля, это теругольник у которого боковые гарни раын 1 в кадой строке и внутри цифры равны сумме 2-х верхних граничащих
def get_str(lst):
    return ' '.join(map(str, lst))


size = 10
pascal_triangle_lst = []

for i in range(size):
    row = [1] * (i + 1)
    for j in range(1, i):
        row[j] = pascal_triangle_lst[i - 1][j - 1] + pascal_triangle_lst[i - 1][j]
    pascal_triangle_lst.append(row)

width = len(get_str(pascal_triangle_lst[-1]))


for line in pascal_triangle_lst:
    print(get_str(line).center(width))

             1
            1 1
           1 2 1
          1 3 3 1
         1 4 6 4 1
       1 5 10 10 5 1       
      1 6 15 20 15 6 1     
    1 7 21 35 35 21 7 1    
   1 8 28 56 70 56 28 8 1  
1 9 36 84 126 126 84 36 9 1






Генераторы списков:
Например нам нужен списко с квадратами знасений
N = 6
a = [0]*N  создаем список с нулями
for i in range(N):
    a[i]=i**2
print(a)    

Все тоже самое можно сдеалть в одну строку и это будет еще и быстрее работать
a = [x**2 for x in range(N)]   в скобках сгачала значение котрое будет вычисляться для заполнения, далее генеаратор который будет генерить занчения и индексы
a = [x%4 for x in range(N)] генеаратор остатков деления на 4
a = [x$2 == 2 for x in range(N)] тут мы проверяем каеие из них четные а какие нет, и заполняем список трумами или фолсами
d_inp = input('введиет числа')
a = [int(d) for d in d_inp.split()] мы введенную строку преобразовываем в список целых чисел d_inp.split() это разбивка по пробелам строки на отлельные элементы списка, далее каддый элемент интуем

Генератор списка с условием

a = [x for x in [-5: 5] if x <4]  после if можно прописывать и составные условия

Генератор вместе с тернарным оператором внутри
a = ['четное' if x$2 == 0 else 'нечетное'  for x in d] тут проверяем значения списка из d на четность, и заполняем этими значениями новый списко
a = ['четное' if x$2 == 0 else 'нечетное'  for x in d if x > 0] тоже првоерка , но только если x>0 т.е. положитеоьных чисел
чтобы было понетнее можно разбивать на строки
a = ['четное' if x$2 == 0 else 'нечетное'
    for x in d 
    if x > 0
    ]

ввод сразу флоат и в список по модулям
print([abs(float(i)) for i in input().split()])    

Генераторр матрицы из нулей и заполнение середины по диагонали еденицами, и вывод на печать
N = int(input())
lst = [[0 for i in range(N)] for a in range(N)]
for i in range(len(lst)):
    lst[i][i] = 1
for i in lst:
    print(*i)
------------------- тоже самое но в строку,  можно оказывается c i и j работаьь и они доступны внтури
n = int(input())

lst = [[1 if i == j else 0 for i in range(n)] for j in range(n)]

for i in lst:
    print(*i)    
_______________________    
прорка на длину ыыода и вывод  , то что более 5 символов
print(*[i for i in input().split() if len(i) > 5])
======================
матрица N*N с читалми от 0 до N
N = int(input())
n = [[j for x in range(N)] for j in range(N)]
for i in n:
    print(*i)

или n = int(input())

lst = [[i] * n for i in range(n)]

for i in lst:
    print(*i)    

========
вводим строку везб чисел, и выводим толькоте что с четным индексом
a = [float(x) for x in input().split()]
print(*[a[x] for x in range(len(a)) if not x%2])
+++++++++++ тоже , но можно сразу делать и выводить каждый второй по функции range
print(*[float(i) for i in input().split()][::2])
 
 илил аналогично моему, но  не забываем что модно внутри и enumerate использовать
 lst = [float(x) for i, x in enumerate(input().split()) if i % 2 == 0]
print(*lst)
_________
матрицу в строку и задом наверед вывести
import sys

# считывание списка из входного потока
s = sys.stdin.readlines()
lst_in = [list(map(int, x.strip().split())) for x in s]
a = [x for row in lst_in for x in row]

print(*[j for i,j in enumerate(a) ][::-1])
еще вывод задом нпред: print(*a[::-1])
или разворот в момент перевода встроку тойже матрицы и далее просто *a
lst = [j for i in lst_in[::-1] for j in i[::-1]]

