Словари:

словари d = {key:data}
d = {"house":"дом", "river":"река"} в данном виде задания словаря  ключ не модет быть строкой без кавычек, но вообще в приципе может
можно обращаться по ключу
d["hause"] получим "дом"  елси в словарь передается 2 значения с одним ключем, то остается только второе, (оно затирает первое). Если обратиться к несуществующему элементу , то будет ошибка
dict(ключ1=значение, ключ2=значение) можно задвать так, при чем "ключи" должны быть строками
если dict используется для преобразования из списка в словарь, то можно использовать в качестве ключей любые элементы, а не только строки, вообще можно в качестве ключей можно брать любые НЕ ИЗменяемые ,  типы данных, в качестве же значения вообще можно использовать любые типы данных.
dict('you'='ты', 'we'='мы', 'they'='они', 'us'='нам')   - так нельзя в данном типе ключи должны быть 
строками но без кавычек
dict('1'='one', '2'='two', '3'='three')    и так тоже нельзя тут и ка кстроки, но если кавычки убратьто будут цифры а в этом типе нельзя задавать как цифры
eeeee

d[True]="Истина"
d
{True:"Истина"}
d[False]="Лож"  мы по факту добавили элемент в наш слварь, если к существующему ключу дать новое зачение, то оно перзапишется
d
{True:"Истина", False:"Лож"}
A = [[1, "один"], [2, "два"]]
dict(A) преобразует в словарь {1:"один", 2:"два"}

len(d) длина словаря
del d[key]  удаление элемента из словаря
"abc" in d это проверяет именно наличие ключа в словаре, но не проверчяет его значение
--------------------
Вводятся данные в формате ключ=значение в одну строчку через пробел. Значениями здесь являются целые числа (см. пример ниже). Необходимо на их основе создать словарь d с помощью функции dict() и вывести его на экран командой:

print(*sorted(d.items()))

Sample Input:
one=1 two=2 three=3
Sample Output:
('one', 1) ('three', 3) ('two', 2)

a = input().split()
a = [x.split(sep='=') for x in a]
a = [[int(j) if j.isdigit() else j for i,j in enumerate(y)]for y in a]
d = dict(a)
print(*sorted(d.items()))
=-=-=-=-
тоде но проще
d = dict(c.split('=') for c in input().split())
for c in d:
  d[c] = int(d[c])   Тут не забываем что если мы обращаеся уже к элементу словаря, то у него мы сразу меняем значение у ключа, а сам ключ остается неизменным
print(*sorted(d.items()))
----------------------------------


Множества- изменяемый тип данных , неупорядочены, но не могут иметь дублей,  и не содержат изменяемых потрахов
создание множества a = set(), в скобки любой итерируемый объект
НЕЛЬЗЯ a = {} это будет не множетво а словаь.
К элементу по индексу обратиться нельзя, 
Множества являются итерируемыми, т.е. в цикле можно его перебрать
Либо мтандартной фукнцией перебора 
it = iter(a)
next(it)  вщяли следубщий элемент в итераторе
len(a)-длинна множества и b in a наличие элемента в множестве
d.add(7) добавление в множества 7-ки, если 2 раза с сделать, то ни сего не произойдет, не будет даже ошибки.просто одинаковый элемент не добавится т.к. множество не может содержать одинаковые элементы
d.update(['abc', 7, 8])  в скобках указывается любой итерируемый объект и проискхордит массовое обновление
d.discard(10) удаляем из множества 10, даже если его и не было не будет ни каких ошибок
d.remove(10) тоже удаление , но уже если элемент не найдет, то будет ошибка
d.pop()  пишется без аргумента и удаляет произвольный элемент и возвращает этот удаленный элемент, для чего это ХЗ
если из пустого множества вызвать pop то будет ошибка
d.clear() очистка множества

ввод множества дробных чисел в троку и их вывод в сортированном виде
ввод строк множество и его подсчет  и приведение к нижнему регистру
a = set(x.lower() for x in input().split())
print(len(a))
или
s = set(input().lower().split())
print(len(s))

------------------
Вложенные циклы и вложенные генераторы списков
a = [(i,j) for i in range(3) for j in range(4)]
print(a)
второй вложен в первый сначала i=0 и пробегает по всему j , далее i=1 и снова бежит j
a = [(i,j) for i in range(3) if i % 3 ==0 for j in range(4) if j%2 == 0 ] все тоже, но с условиями
a = [f'{i}*{j} = {i*j}' (i,j) for i in range(3) for j in range(4)]  тут по факту мы заполняем таблицу умнодения
a = [x for row in matrix for x in row] тут мы матрицу преобразуем в строку, тут показано, что во вложенных циклах мы можем использовать переменные объявленные ранее
=============
далее идет вложенный генератор списка уже в первое  действие, где раньше быо просто Х
M, N = 3, 4
matrix = [[a for a in range(M)] for b in range(N)]
print(matrix)
В данном случае сначала отрабатывает правый генеартор, напрмеир b = 0 , далее запускается уже левый мы  в него уже b не пердаем, а просто генерем спико и получаем в итоге
[[0,1,2], [0,1,2], [0,1,2]]

Так можно возвести в квадрат многомерный список
A = [[1,2,3],[4,5,6],[7,8,9]]
A = [[x**2 for x in row] for row in A] тут пробегает правый и берет строку 0, строку 0 каждыый элмент возводим в квадрат и т.д.
[[1,4,9], [15,25,36], [49,63,81]]
A = [x**2 for row in A for x in row] отличие этого от верхнего , тчо тут на выхолде получисм 
[1,4,9,16,25,36,49,64,81]
одномерныый список квалратов, а в верхнем выражении такой же двумерный как и был на входе.

Транспонирование матриц,
A = [[1,2,3,4], [4,5,6,7,8], [9,10,11,12]]
A = [[]row[i] for row in A] for i in range(len(A[]0))]
тут берем ранж по длине вложенного элемента матрицы т.к. потмо как раз будет столкьо элеметов сколкьо сейчас длина одного, например взяли 0, дадее во вложенном цикле мы в 0 элемент матрицы вкладываем нулевые элементы с кадого вложенного элемента матрицы,
дале 1, и мы в 1 элемент матрицы вкладываем все 1-е элеметы из кадого вложенного и т.д. формируем столько элеметов сколько длина вложенного элеметта, но количество элеметов в каждом теперрешнем элеметет уже как раньеш было вложеных элеемтов
[[1,5,9], [2,6,10], [3,7,11], [4,8,12]]
=============
тут уже вложенный геенратор идет в  роли итерируемого объета т.к. он генерирует список значит его можно итерировать
g = [u**2 for u in [x+1 for x in range(5)]]  список квадратов от 1 до 5
сначала генерим список от 1 до 5 , потмо его используем как итерирумый объект
------------------------
строка список в квадратную матрицу 
a = list(map(int, input().split()))
N = int(len(a) ** 0.5)
b = [[j for i,j in enumerate(a[N*y:N*y+N])] for y in range(N)]
print(b)
тоже но не вычисляем поиции а берем объект iter он сам останавливается при итерации и нам нужно пройти только необходимое количество шагов
l = list(map(int, input().split()))
n = int(len(l)**0.5)
it = iter(l)
m = [[next(it) for y in range(n)] for x in range(n)]
тоже но тут интересный момент старт итерации берем уже по томучто спикок дробим в соответвии с N
и  у нас всегда будет старотовый индекс
lst_in = list(map(int, input().split()))
N = int(len(lst_in) ** 0.5)
lst = [lst_in[i:i+N] for i in range(0, len(lst_in), N)]
print(lst)