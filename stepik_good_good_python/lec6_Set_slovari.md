Словари:

словари d = {key:data}
d = {"house":"дом", "river":"река"} в данном виде задания словаря  ключ не модет быть строкой без кавычек, но вообще в приципе может
можно обращаться по ключу
d["hause"] получим "дом"  елси в словарь передается 2 значения с одним ключем, то остается только второе, (оно затирает первое). Если обратиться к несуществующему элементу , то будет ошибка
dict(ключ1=значение, ключ2=значение) можно задвать так, при чем "ключи" должны быть строками
если dict используется для преобразования из списка в словарь, то можно использовать в качестве ключей любые элементы, а не только строки, вообще можно в качестве ключей можно брать любые НЕ ИЗменяемые ,  типы данных, в качестве же значения вообще можно использовать любые типы данных.
dict('you'='ты', 'we'='мы', 'they'='они', 'us'='нам')   - так нельзя в данном типе ключи должны быть 
строками но без кавычек
dict('1'='one', '2'='two', '3'='three')    и так тоже нельзя тут и ка кстроки, но если кавычки убратьто будут цифры а в этом типе нельзя задавать как цифры
eeeee

d[True]="Истина"
d
{True:"Истина"}
d[False]="Лож"  мы по факту добавили элемент в наш слварь, если к существующему ключу дать новое зачение, то оно перзапишется
d
{True:"Истина", False:"Лож"}
A = [[1, "один"], [2, "два"]]
dict(A) преобразует в словарь {1:"один", 2:"два"}

len(d) длина словаря
del d[key]  удаление элемента из словаря
"abc" in d это проверяет именно наличие ключа в словаре, но не проверчяет его значение
--------------------
1. Пустой словарь: {} или dict()

2. Ключ - значение: в {} это : , а в dict() это =

3. Ключ в {} не может быть строкой без кавычек!

4. Ключ в dict() не может быть строкой в кавычках. Тут же правило называния ключа такое же как у переменной (не начинать с цифры)

5. Как в видео уроке было сказано, словарь можно задать через список перемещенный в dict()
--------------------


d.items()  #показывает итемы словаря т.е. значения и  ключи словаря, в форме списка. dict_items([('one', 1), ('two', 2), ('three', 3)])

Сортируем функцией:

print(sorted(d.items()))   #получаем такой результат из [('one', 1), ('two', 2), ('three', 3)]    =>  [('one', 1), ('three', 3), ('two', 2)]

Добавляем магическую звездочку * в print() (или мохнатую точку, снежинку, кому как удобно), чтобы убрать первый внешний экранирующий элемент при выводе и получается результат ('one', 1) ('three', 3) ('two', 2)
------------------
Вводятся данные в формате ключ=значение в одну строчку через пробел. Значениями здесь являются целые числа (см. пример ниже). Необходимо на их основе создать словарь d с помощью функции dict() и вывести его на экран командой:

print(*sorted(d.items()))

Sample Input:
one=1 two=2 three=3
Sample Output:
('one', 1) ('three', 3) ('two', 2)

a = input().split()
a = [x.split(sep='=') for x in a]
a = [[int(j) if j.isdigit() else j for i,j in enumerate(y)]for y in a]
d = dict(a)
print(*sorted(d.items()))
=-=-=-=-
тоде но проще
d = dict(c.split('=') for c in input().split())
for c in d:
  d[c] = int(d[c])   Тут не забываем что если мы обращаеся уже к элементу словаря, то у него мы сразу меняем значение у ключа, а сам ключ остается неизменным
print(*sorted(d.items()))


d.get(key) возвлращает или , значение , или ни чего елси нет, либо можно вернуть False если прописать
если обратиться просто d[key] , то если  нет то вернет ошибку.
d.setdefault(key, default) елси не находит , то создает ключ, с со значением default
del d[3] удадление из словаря
d.pop(key)  удадение элемента с возвтратом значения, можно прописать False, чтоб при ошибке не было ошибки а возврвт нужного нам был Ложи
d.keys возврат списка ключей, по дефолту цикл for идет как раз по keys
d.values возврат списка значений, если нужно обойти по values То пишщем for x in d.values()
for x in d.items()  возвращате кортежи ключ:значение
for key,value in d.items() сразу пребор получением ключ значение
d.update(d2) обновление 2-м
d3={**d1, **d2}  сложение, можем и поменть местами
d1 | d2 тоже объединение словарей
----------------------------------



Множества- изменяемый тип данных , неупорядочены, но не могут иметь дублей,  и не содержат изменяемых потрахов
создание множества a = set(), в скобки любой итерируемый объект
НЕЛЬЗЯ a = {} это будет не множетво а словаь.
К элементу по индексу обратиться нельзя, 
Множества являются итерируемыми, т.е. в цикле можно его перебрать
Либо мтандартной фукнцией перебора 
it = iter(a)
next(it)  вщяли следубщий элемент в итераторе
len(a)-длинна множества и b in a наличие элемента в множестве
d.add(7) добавление в множества 7-ки, если 2 раза с сделать, то ни сего не произойдет, не будет даже ошибки.просто одинаковый элемент не добавится т.к. множество не может содержать одинаковые элементы
d.update(['abc', 7, 8])  в скобках указывается любой итерируемый объект и проискхордит массовое обновление
d.discard(10) удаляем из множества 10, даже если его и не было не будет ни каких ошибок
d.remove(10) тоже удаление , но уже если элемент не найдет, то будет ошибка
d.pop()  пишется без аргумента и удаляет произвольный элемент и возвращает этот удаленный элемент, для чего это ХЗ
если из пустого множества вызвать pop то будет ошибка
d.clear() очистка множества

ввод множества дробных чисел в троку и их вывод в сортированном виде
ввод строк множество и его подсчет  и приведение к нижнему регистру
a = set(x.lower() for x in input().split())
print(len(a))
или
s = set(input().lower().split())
print(len(s))

------------------
Вложенные циклы и вложенные генераторы списков
a = [(i,j) for i in range(3) for j in range(4)]
print(a)
второй вложен в первый сначала i=0 и пробегает по всему j , далее i=1 и снова бежит j
a = [(i,j) for i in range(3) if i % 3 ==0 for j in range(4) if j%2 == 0 ] все тоже, но с условиями
a = [f'{i}*{j} = {i*j}' (i,j) for i in range(3) for j in range(4)]  тут по факту мы заполняем таблицу умнодения
a = [x for row in matrix for x in row] тут мы матрицу преобразуем в строку, тут показано, что во вложенных циклах мы можем использовать переменные объявленные ранее
=============
далее идет вложенный генератор списка уже в первое  действие, где раньше быо просто Х
M, N = 3, 4
matrix = [[a for a in range(M)] for b in range(N)]
print(matrix)
В данном случае сначала отрабатывает правый генеартор, напрмеир b = 0 , далее запускается уже левый мы  в него уже b не пердаем, а просто генерем спико и получаем в итоге
[[0,1,2], [0,1,2], [0,1,2]]

Так можно возвести в квадрат многомерный список
A = [[1,2,3],[4,5,6],[7,8,9]]
A = [[x**2 for x in row] for row in A] тут пробегает правый и берет строку 0, строку 0 каждыый элмент возводим в квадрат и т.д.
[[1,4,9], [15,25,36], [49,63,81]]
A = [x**2 for row in A for x in row] отличие этого от верхнего , тчо тут на выхолде получисм 
[1,4,9,16,25,36,49,64,81]
одномерныый список квалратов, а в верхнем выражении такой же двумерный как и был на входе.

Транспонирование матриц,
A = [[1,2,3,4], [4,5,6,7,8], [9,10,11,12]]
A = [[]row[i] for row in A] for i in range(len(A[]0))]
тут берем ранж по длине вложенного элемента матрицы т.к. потмо как раз будет столкьо элеметов сколкьо сейчас длина одного, например взяли 0, дадее во вложенном цикле мы в 0 элемент матрицы вкладываем нулевые элементы с кадого вложенного элемента матрицы,
дале 1, и мы в 1 элемент матрицы вкладываем все 1-е элеметы из кадого вложенного и т.д. формируем столько элеметов сколько длина вложенного элеметта, но количество элеметов в каждом теперрешнем элеметет уже как раньеш было вложеных элеемтов
[[1,5,9], [2,6,10], [3,7,11], [4,8,12]]
=============
тут уже вложенный геенратор идет в  роли итерируемого объета т.к. он генерирует список значит его можно итерировать
g = [u**2 for u in [x+1 for x in range(5)]]  список квадратов от 1 до 5
сначала генерим список от 1 до 5 , потмо его используем как итерирумый объект
------------------------
строка список в квадратную матрицу 
a = list(map(int, input().split()))
N = int(len(a) ** 0.5)
b = [[j for i,j in enumerate(a[N*y:N*y+N])] for y in range(N)]
print(b)
тоже но не вычисляем поиции а берем объект iter он сам останавливается при итерации и нам нужно пройти только необходимое количество шагов
l = list(map(int, input().split()))
n = int(len(l)**0.5)
it = iter(l)
m = [[next(it) for y in range(n)] for x in range(n)]
тоже но тут интересный момент старт итерации берем уже по томучто спикок дробим в соответвии с N
и  у нас всегда будет старотовый индекс
lst_in = list(map(int, input().split()))
N = int(len(lst_in) ** 0.5)
lst = [lst_in[i:i+N] for i in range(0, len(lst_in), N)]
print(lst)

__________________________________
кортежи
почти ка списки, но не изменяемые
a = (1, 2)  a = 1, 2
если 1-о значение
a =(1, )  оставляем висящую запятую  a = 1,
распаковка кортежей
a, b, c = (1, 2, 3)  распакуются каждый в свое.
распаковыыать в разные переменные можно любые итерируемые объеты
a, b, c = ["один", "dwa", "tri"]
len(a) длинна коретежей
a[0]  обращение к 1-у элементу
a[:] -при работе со списокм создается полная копия, а при работе с кортежем не создается, записывается ссылка на тот же элемент

в отличии от списков, кортежи могут быть ключами в словарях
занимают в среднем в 2-ф раза меньше памяти
a = ()   a = tuple() создание пустого кортежа
сложение через +, на выходе новый кортеж, как сумма 2-х дургих
a * 5 кортеж можно умножать , в итоге будет в кортеже необходиоме количество элементов, но не вложенные кортежи

a[1].append("5") сам кортеж не изменяемый тип, но если в кортеже есть изменяемый тип, например список, список уже внутри менять можно, тут добавили 5 внутрь списка.
потмому, что не изменяемые по сути это только ссылки на элементы кортежа, а не сами элменты

tuple.count() возвращает число найденных элементов 
tuple.index() возвращает индекс искомого элемента можно ограничивать tuple.index(5 ,2, 6) ищем 5 в диапазоне от индекса 2 до индекса не включая 6

Генераторы множеств
формируется точно также как и генератор списков, только скобки фигурные, внутри почел вывода множество не упорядочено, и не имеет дублей.
a = {x**2 for x in range(1, 5)}
a = {int(x) for x in lst} преобразует список разных эдементов, возвожно строк из цифр, в множество цифр
a = {int(x) for x in lst if int(x) > 0}  генератор с условием

Генератор словарей
очень похоже на генератор множеств, но появляется  еще ключ

a = {x: x**2 for x in range(1, 5)}
a = {key.upper(): int(value) for key, value in d.items() } ключи переводим в заглавные буквы, занчения интуем, а генератор достает ключ значение из словаря, методом items (items показывает словарь в форме списка кортежей)
a = {int(value): key for key, value in d.items if 2 <= int(value) <= 5}  меняем ключи и значения местами, при этом занчени болжны быть в диапазоне от 2 до 5

---------------------------
создать словарь из строки, и вывести 4-й элемент
строка "1 ужасно неудовлетворительно удовлетворительно прилично отлично"
--
s = input().split()
marks = {int(s[0]) + i: value for i, value in enumerate(s[1:])}
print(marks[4])
--
lst = list(input().split())
d = {}
for i in range(len(lst) - 1):
    lst_key = [x for x in range(int(lst[0]), (len(lst)) + int(lst[0]) - 1)]
    d[lst_key[i]] = lst[i + 1]
print(d[4])
-----------------------------

Делаем множество без учета звгланая не заглавная, можно или уже элемент сажать или при приеме до разбития списка сажать буквы
st = {x.lower() for x in input().split() if len(x) >= 3}
print(len(st))

text = {word for word in input().lower().split() if len(word) > 2}
print(len(text))

-----------
перебор строки с добавлением в словарь и подсчет повторов
d = {}
for w in input().lower().split():
    d[w] = d.get(w, 0) + 1 
print(d.get('и', 0))

или 

lst = input().lower().split()
d = {i: lst.count(i) for i in lst}
print(d.get('и',0))