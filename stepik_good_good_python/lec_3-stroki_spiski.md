строки вводятся в ""  или ''
можно вводить многостроки с тройными кавычками '''     '''    """     """
"""тут строка
и тут строка"""
* умнодение строки на целое число, по сути размножение в необходимое количество раз
len("stroka) считает длину строки
in проверяет вхождение подстроки в строку ha in ahara  будет True
сравнение строк  'кит' > 'кот' идет побуквенное сравнение, в зависимости от положения буквы в алфавите итаблице ASCII,
как  только произошло сравнение, то дальнейшее сравление не производится
ord('k')  узнаем код символа в питоне

При умножении строки на число не происходит преобразование типов, а происходит умножение 
строки на число, т.е. она  копируется стлько раз
chr - узнать  символ по коду в python
ord - узнать код по символу
внутри f строк можно делать срауз вычисление
print(f"Коды: {a} = {ord(a)}, {b} = {ord(b)}")

К каждому символу в стоке python можно обрптится по индексу, начала отсчетас 0
если цифра положительная то идем с начала строки, если индекс пишем отритцательный , то с 
конца строки
Можно просто из строки брать индекс panda[3] выведет d , т.к. помним , что отстчет идет
от 0
Срез строки, это последовательномть символов в puthon из строки, при чем в котоой последний индекс не берется
panda[1:4] выведет "and"   1 -символ это "a" , 4-й это тоже "а" но он не выводится
Можно указать начальный , но не указывать последний тогда берется начальнывй и все до конца
panda[2:] "nda", 
Либо не указываем начальный , но указываем конечный panda[:3]  "pan"
если ввести panda[:] то получаем ту же самую строки
Можно в срезах брать и отритцательные значения
panda[2:-2] т.е. "n" т.к. "n" символ с идексом 2 , по -2 берем и отсчитываем с конца и тоже на него только приходим
можно записать [-2:2] но ни чего не получим т.к. срез ни чего не формирует тоже как [4:2]
строки перебирать можно с разным шагом stroka[start;stop;step], по умолчанию шаг "1"
например step "2", даст в итоге переход каждый раз на кадый второй символ от начала старта
panda[1;5:2] выдаст "ad"
panda[1::2] начала от символа с индексом 1 , до конца с шагом 2
panda[::2] полную строку перебираем с шагом 2
panda[::-1] перебираем всю строку начиная с конца
вывод 5-х пяти символов в обратном порядке print(s1[4::-1])
СТроки являются не изменяемыми объектами: т.е. мы не можем изменить любой символ в ней,
изменения можно сделать путем склейки в новую строку
s1 = "panda"
s2 = "P" + s1[1:]  тут мы берем заглавную ьукву и прикклеиваем к ней старую строку с символа с индексом 1, т.е. с со второй буквы получается
--------------------
вывод да нет
print('ДА' if flag else 'НЕТ')
-----------------------

строковые методы
переменная.метод(аргументы)
методы upper, lower, count, find, index, replace, isalpha, isdigit, rjust, 
split, strip
s1.upper() все заглавные, "PYTHON" чтоб сохранить нужно s2 = s1.upper()
s1.lower() все в строчные "python"
s1.count(sub, start, end)  число повторений подстроки "sub" в строке s1, start, end
необязательные параметры индекса начала отсчета и индекса конца
s1.find(sub, start, end) находит подстроку "sub" и отдает индекс первого вхождения start, end необязательные
если не находится подстрока метод find возвращает -1
s1.rfind() поиск с конца в начало
s1.index() работает как find но он возвращает не -1 , а именно ошибку, это бывает нужно если нудно обрабатывать именно ошибки центрадизованно
s1.replace(old, new, count=-1) меняет old подстроку на new, count необязательный параемтр, указывает максимальнео количество замен
по умолчнию -1 т.е. не ограниченное количество замен
s1.isalpha() определет полнсотью ли строка состоит из букв, при чем " " пробелы если есть или точки, то это строка уже не 
состоит полностью из букв
s1.isdigit() если срока состоит полностью из цифр, при чем например 5.3 это не пройдет т.к. точка это не цифра
s1.rjust(wight, fillchar = ' ') ,возвращает стоку необхоимой длинны, и при необходимости слева добавляет необходимое количесов символов
в данном случае пробелы. s1 = "abc"  s1.rjust(5)    '  abc'  слева добавили до 5 символов
можно так добавлять незначащие нули в каких либо числах. Если  указать динну строки короче чем она есть, то на выходе
будет таже самач строка
s1.ljust()  тоже самое что и rjust Но добавляет символы справа
s1.split(sep=None, maxsplit= -1)  разбивка строки на список строк, разбивка по сепаратору sep
s1 = 'Иванов Иван'  s1.split(" ")   ['Иванов', 'Иван']
Если в троке есть и пробелы и другие разделители, то лучше сначала подчистить с помощью replace от не нужных символов, 
а потом уже делить эту строку по разделителям
s1 = '1,  2,3    ,4'
s1.replace(" ", "").split(",") тут идет последовательный вызов методов к обрабатываемой строке и на выходе
получаем уже очищенный красивый список ['1', '2', '3', '4']
s1.join(список)  обратная операция , идет сбор из списка строк , одна строка
", ".join(spisok) в кавычках указываем чем будут делится символы в строке, в данном случае запятая и пробел
fio = "Иванов Иван Иванович"    ", ".join(fio.split())    'Иванов, Иван, Иванович'
s1.strip() убирает пробелы , переносы строк (незначащие символы) в начале и в конце строки
strip может стрипать любые незначащие символы переданные ему в качестве аргумента
s1.lstrip()
s1.rstrip() удаляют справа и слева незначащие символы
s1.capitalize()  делает первую букву строки заглавной
_______________________________
Замер времени выполнения скрипта
import time
raw_text = "dobavlyaem---slagi--slug-k--url---adresam"*1_000_000

start = time.perf_counter()
rez = raw_text.replace("---", "-").replace("--", "-")
print("Сначала --- затем --, время выполнения =", time.perf_counter() - start)
_______________________________

a, b, c = map(str,input().split())
print(a.rjust(3,"0"),b.rjust(3,"0"),c.rjust(3,"0"), sep='\n')
вывод кучи переенных в столбик, если ставить \n после каждой переменной 
то будут лишние пробелы

Спец символы-их комбинация даже из нескоьких букв и пр., считается системой как 1 служебный символ
\n -перевод строки
\\ обратный слэш
\'
\"
\t горизонтальная табуляция
\b backspace
\r возврат каретки
Если нужно пропечатать обратный слэш то нудно ставить два слэша
часто так делают при написании путей c:\\progra\\project  чтобы не получить случайно специсимвол в строках
Если нужны кавычки внутри строки, то нудно или внешние одинарные делать, а внутри двойные
или экранировать ковычки слэшем \
Сырые row строки, если нам нужно свободно выводить строку со всякой фигней внтури, то можно сделать по виду
s1 = r"d:\progra\figna"  в этом случае строка не будет обращаь что находится внутри

3 способа формирования строки
1. Классический: "меня зовут" + name ", мне" + str(age) + " и я люблю Python"
2. 1) строки с методом format: "меня зовут {0}, мне {1}, и я люблю python".format(name, age)
в данном случае можем подставлять переменные, которые мы по порядку выставили в параметры метода
мы можем использовать несколько раз именование переменной главное указать ее номер из параметров
      2) "меня зовут {name}, мне {age}, и я люблю python".format(fio=name, old=age) 
3. с версии 3.6 есть f строки f"меня зовут {name}, мне {age}, и я люблю python"
внтури фигурных скобок f строк можно использвоать люьые конструкции python т.е. 
 складывать вычиать, upper  и производить любые другие действия

_________________________________________
списки
_________________________________________
создается в []  итам через зяпятую перечисляем, в список могут быть любые значения,
список может содержать внутри другой список.
К эементам списка можно обращаться по индексу a[2], можно обращаться с конца , тогда это a[-1], -1 это последний 
элемент, и так далее -1 -2 и т.д., 
Список это изменяесяй тип, тут можно заменить и переписывать элемент, вместо числа можно записать строк у ит.д.
Есть функция list которая создает список, может преобразовать другой элемент в список.
a = list() создаст пустой список в а.
a = [] создание пустого спсика
a = list("stroka") создаст список a ['s', 't', 'r', 'o', 'k', 'a' ]

функции списокв
len(a) вычисление количества элементов списка
min(a) нахождение минимума элементов списка
max(a) нахождение макисимума среди элементов списка
sum(a) нахождение суммы всех элементов списка
среднее sum(a)/len(a)
sorted(a) возвращает НОВЫЙ отсортированный список
sorted(a, reverse = True) сортировка по убыванию
max min sorted работают со всеми типами данных с которыми можно проводить ><
sum работает толкьо для чисел

+ сложение списка с числом нельзя, только с чилом в списке a += [1] добавит в конце еще элемент
+ объединение списков, [1, 2 , 3] + [4, 5] = [1, 2, 3, 4, 5]
складывать список просто с числом нельзя
* дублировагние списков [1, 2] * 3  = [1, 2, 1, 2, 1, 2]   по сути это умножение. но только на целые числа
in проверка вхождения элемента в спсикок, возвращает True или False , 3 in [1, 2 , 3]  = True
можно проверять вложенность списка в список, но список долженн быть именно как вложенный список , ане кучка элементов
del(a[1])  удаляет 2-й элемент в списке т.к. элементы считаются с 0, после удаления список сдвигается на удаленный элемент
a.append(данные) добавляет в коенц списка элемент
a.insert(позиция, данные)
a.[1] просто заменяет элемент в списке
a.[1] *= 2 просто умножает элемент в списке
print(*a) вывод списка не ввиде списка а ввиде строки с элементами 
++++++++
book = [input(), input(),int(input()), float(input())]

del book[2]
book[1] = 'Пушкин'
book[2] *= 2
++++++++
print(*input().split() + ["Москва", "Тверь", "Вологда"])   делаем список со ввода , добавляем второй, и выводим поэлементно
вывод поэлементно, самый низкий приоритет имеет

___________________
срезы списков
Так же как и у строк 
a[1:3] срез элементов с 1 по 2, и не включает 3
a2 = a т о это будет один и тот же список и и если отредактирвоать 1-н второй тоде будет отредактирвоан
если нужна именно копия то нудно a2 = list(a)
a[1:-1] со 2-го (т.к. с 0 считаем) и до последнего , но его не включает
a[start:stop:step]
a[start:stop:-step] перебор с конца
a[1:2][4:5] срезы можно делать подряд несколько раз, например сначала срезать потом развернуть илил наоборот, 
a[::-1][1:2]  илил роазвернуть и в прямом пордке обрабатывать елси так удобно
Групповое присваивание
Замена части данных по срезу a[1, 2, 3, 4, 5, 6]    a[1:2] = [[хор, отл]]   a[1, 'хор', 'отл', 4, 5, 6]
a[1:3:2] = [0, 0, 0] a[1, 0, 'отл', 0, 5, 0] но тут нужно следить что мы присваиваем столько же значений сколько выбираем
в срезе а то может получится, что присваеваем не больше и тогда будет ошибка, а если  меньше то наш список уменьшится до 
размера списка не остатков среза которые не меняли и этих значений
можно присваивать через срез просто новые значения a[1:3] = 10, 20
Сравление списков
списки можно сравнивать как строки <> == идет по символьное сравнение, если в однмо списке элементов больше , он 
автоматом зачит больше другого с любыим значениями, сожно сравнивать списки где есть и цифры и строки, но эти элементы 
должны бть на одних и тех же индексах. иначе будет ошибка, Питон ен моет сравнивать строки с цифрами
Если сравнение по какомуто символу уже дало или true bkb false То дальше уже ни чего не сравнвиается
---------
a, b = sorted(s[:2])  присваивание срауз несколькомим переменным зачений из списка с сортировкой их  
c, d = sorted(s[2:])

____________
Методы списков
a.append() добавляем элемент в конец
a.pop() удаляет последний элемент, или элемент  у которого указан индекс в скобках, и возвращает этот элемент в ответ
a.remove() ищет и удаляет элемент 1-й элемент по сомому элементу. При этом если искать True или False то будет удалться
1 или 0 т.к. идут преобразование типов. Если не находит , то ошибка
a.insert(индекс, данные) вставка в нужное место данных
a.clear() очистка списка
a.count(значение) ищет данные и возвращает количество совпадений, если не находит то вернет 0
a.index(элемент) возвращает индекс первого найщенного элемента, если нужно искать следующий  нужно указывать стартовый элкмент
a.index(элемент, start_index) если не находит , то ошибка. ЧТо бы не получать ошибку лучше сначала проверит на 
то что элемент естьв спсике in , и если True тогда продолжать
a.reverse() разворачивает список в обратном порядке
a.sort() сортировка спсика по возрастанию a.sort(reverse = True) сортировка по убыванию sort также работает и для строковых значений

можно при работе сразу обращаься не только к элементу списка но и сразу к потрахам самого элемента, к примеру к символу
строки в списке a[1][5]  выведет 6 букву строки , которая является 2-м элементом списка

Способы создания нового списка
a2 = a1[:]
a2 = list(a1)
a2 = a1.copy()
+++++++++++++
можно при вооде сразу прмиенять методы к строкам и отфильтровывать что не нужно
print(input().replace('+7', '8').replace('-', '')) сразу меняем +7 на 8 и убираем дефисы
+++++++++
17-32 03-06-2022
-----------
принятие любого количества аргументов и в int их
p(*map(int,input().split()))
---------
выборка двоек из введенной строки
print(list(map(int, input().split())).count(2))
Двумерные списки:
a = [[1,2], [3,4], [[5,6}]]
a = [a1[:], a1[:]]]  дублрование спсика из другого списка
a[1][2] обрвщение к элементам внутреннего спсика
a[1] = [0] * 5  пример зполнения внтуренниего списка нулями, в данном случае мы сформировали 
новый список и присвоили этот новый на старый
a[1][:] = [1] * 5 берем 2-й вложенный списко , берем его полный срез и заменяем данные на едеицы,
а не создаем новый список для этого
lst = a + [b]  сложение списков, но в этом случае добавляются не значения из второго списка
а добавляется именно как вложенный список, в качестве элемента
+++++
lst = [input().split(), input().split(), input().split()] создание списка каждый запосо с новой
строки
+++++
можно создать список из списков
lst = [lst1, lst2, lst3]
lst = [a] + [b] + [c]  это одно и тоже
чтобы найти элемент который содержится во вложенном списке , можно весь список преобразовать в строку 
и сделать in в этой строке. Либо просуммровать все вложенные элементы и так же in
или можно проверить count также 

Если нужно развернуть строку или список, то можно чреез a.reverse() либо можно развернуть через срезы
путем среза с конца в начало

a = int(input()) - 2
lst = [1, 1]
while a>0:
    b = lst[-2] + lst[-1]
    lst.append(b)
    a -=1
print(*lst) 

можно заменить на 
n = int(input())
lst = [1, 1]

while len(lst) < n:
    lst.append(lst[-2] + lst[-1])
 
print(*lst)   м
мы просто контролируем длину спсика и не заморациваемся со счетчиками,

while a > 0: можно заменить на while a:  но нужно учитывать что если ввели -a то цикл зациклится

Преобразование строки с список чисел
lst = [int(item) for item in t.split()]

Обратока строки сразу с разбивкой на список числе и их сложение
e = map(int, input().replace(' ', '').replace('+', ' +').replace('-', ' -').split())
print(sum(e))

обрабтка строки, сразу выдергаивем цифры и упорядочиваем
st = '1234567890'
a = list(set([y for x,y in enumerate (input()) if y in st]))
a.sort()
print(*a if a else ['НЕТ'])
если оператор * прсото оставить ТО будет Н Е Т чтбы он не трогал нет как отедьный элемент в []

print(*sorted(set(int(c) for c in input() if c.isdigit())) or ['НЕТ'])   тое самое