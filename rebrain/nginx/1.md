
    main — базовые директивы конфигурации, которые влияют на сам процесс nginx — например, под каким пользователем ему запускаться или где сохранять pid файл;
    work_[rocesses по количеству ядер]
    events — здесь описываются параметры обработки подключений — какую библиотеку использовать, какое максимальное число подключений будет обслуживать один воркер; 
    mail — в данной секции описывается конфигурация, которая относится к проксированию почтовых протоколов (imap, smtp, pop3) — в этом практикуме мы ее не разбираем;
    
    http — основная секция, в которой мы будем работать, — здесь задаются основные параметры http, такие, как MIME types, sendfile и другие;
    http { server } — подсекция http, в которой описываются виртуальные хосты обрабатываемые nginx.

    include mime.tipes файл с описаним типов, вниуз описано все подклчаемые типы, мы эти типы запрашиваем в запросе, например  файлик иммеет расширение html и тогда контет тип text/html, какой контент тайп какому файлу соответствует
    default tipe не нашли тип, используем это
    log_format main  формат логов с названием main и нижу будет описание этого формата
    access_log main адрес файла лога и в какком формате пишем, можемвыбрать из типов описанных ранее
Важно то, что в ходе такого подключения с использованием * подключение файлов производится в алфавитном порядке поэтому если вам нужно какой-то конфигурационный файл поставить первым для выполнения, его можно назвать с использованием числа в качестве первого символа имени файла.

server_name example.com www.example.com;
wildcard правила, которые, к примеру, позволяют обрабатывать все субдомены — server_name example.com *.example.com;.

использование пустого server_name ("") — оно определяет, что запросы без Host (к примеру, по IP-адресу) будут обрабатываться этим server.

Так же важно знать, что если в директиве server_name указать значение из символов недопустимых в DNS именах (@, _, #, подробнее в rfc1034), такая директива будет обрабатывать запрос с любым hostname.

Так же следует знать, что длина значения директивы server_name ограничена, и в случае необходимости увеличения значения, необходимо откорректировать значения параметров server_names_hash_max_size server_names_hash_bucket_size на уровне http.

Кроме описанных выше опций, есть еще одна очень важная опция — default_server, которая определяет, что конкретно этот сервер будет использоваться по умолчанию для пары IP-адрес — порт, в случае, если клиент не прислал в запросе заголовок Host (или прислал невалидный). Например, представим, что у нас есть 3 server:

    server_name ""; listen 80 default_server;
    server_name example.com; listen 80;
    server_name ""; listen 127.0.0.1:80 default_server;

Каждый из них имеет право жить и будет обрабатывать разные запросы.

Директива return

    return 200 "hello from nginx"; — вернет соответствующий текст с кодом 200;
    return 301 http://example.com; — вызовет redirect с кодом 301 на соответствующую ссылку.
Особенно популярный пример — редирект всех доменов по умолчанию на HTTPS — return 301 https://$host$request_uri;.

Получение данных по telnet из http

telnet 8.8.8.8 80 далее происходит connect
если все ок, можно подать данные
GET /index.html HTTP/1.1
Host            #Host это обчзательный хедер при использовании HTTP1.1
X-api-key: 324324  # свои заголовки

Если используется хэдер для внутрненних нужд, не определенных RFC , то в начале необходимо добавить "X-"

Вначале может происходить работа по протоколу 1.1 и далее переключиться уе на 2
В HTTP2 данные передаются бинарно для ускорения, но в браузере можно уже посмотреть раскрытые данные

HTTP 1.0 сразу закрывает соединение после ответа
HTTP 1.1 держит соединение открытым. протокол синхронный, не сжимает хэдэры
HTTP 2 протокол уже асинхронный , можно сразу отправить несколько запросов и ждать ответы, сжимает хэдэры, есть сервер push, когда сервер оправляем вам , того , что вы не запрашивали



Коды ответов 
1XX для работы web socket типа продолжай передачу
2ХХ все ОК
3ХХ редиректы, если есть 3XX, браузер ищет location: http://ya.ru  и переходит по этому адресу.
4ХХ клиент ошибся  406 не применимо, например не понравился протокл
5ХХ ошмбки на стороне сервера

Есть версии stable и mainline . в mainline в принципе все уже довольно стабильно.

отдичие RELOAD и RESTART , при reload nginx запускает новые воркеры, и начинает ими обрабатывать, а старые постепенно убиватся, когда они заканчивают работу
на самом деле подключение по адресу ya.ru и по ip ни на что не влияет nginx будет определять куда подключаемся по хедеру заголовку HOST

Простейшая конфигурация
При любых запросах возвращаем ответ код 200 и , то что идет далее т.е. "APP"
server {
    listen 80;
    server_name app.kis.im;
    RETURN 200 "APP";
}

Иногда в конец стоит добавить символ переноса RETURN 200 "APP"\n;  т.к. при подключении если руками перенесешь , а там не будет переноса в рамках этой же сесиии то он посичтает как новео
Если HOST не валидный или не указан, то отдастся самый первый, если разные файлы, то в алфавитном порядке файлы пойдут , если не хотим от этого зависеть, то используем директиву default_server после названия сервера

curl -v покает логирвоание , и он сам добавит заголовок HOST взяв имя подключения , если мы не поменяли это сами
в ответ accept*/* это значит принимает он все что отдадут
curl -D -    показывает даб хэдерс показывает выводить ответы сервера, если после дифиса  нет имени фалйа, то идет выод на терминал
curl -D - -o /dev/null вывод в терминал заголовков, а самой страницы в dev/null но с выводом скорости зангрузки
curl -D -s - -o /dev/null   silent без вывода скорости загрузки
curl -D -s - -H "Host: www.ya.ru" перезаписываем заголовок host
