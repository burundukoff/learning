1. верхняя граница медленных алгоритмов сортировки O(n^2)
2. Если нет переменных , то равно всегда O(1), сколкьо угодно операций, если это не зависит от размера данных
3. Если n элементов , то у for уже будет O(n) 
4. присваивание цикла это O(1)
5. если циклы вложены, но это с одними и теми же перменными , то это свсе равно O(n)
6. если ижет 2 массива с разными переменными O(n+m)
7. если вложенные циклы с разными перменными O(m*n)
8. если m=n То тогад уже ранво все O(n)
9. если 1-о слагаемове более чем в 2-а раза больше другого то его можно не учитывать
10. Сложность бинарного поиска O(log n)
11. O(n!)
12. Массивы: чтение элемента O(1), добавка и удаление в конец O(1), добавка или удаление середина O(1)
13. Динамические массивы , все тоже, добавление значения с изменением размера массива O(n)
14. Динамический массив на python содержит на самом деле ссылки на элементы, ане сами элементы, поэтому он как бы содержит одинаковые элементы (ссылки)
15. Объединение списков O(m+n)
16. Срез списка O(n)
17. Односвязные списки,  добавление/чтение в конец или начало O(1), чтение/вставка/удалениме произвольного элемента O(n)
удаление 1-го элемента O(1), удаление последнего O(n)
18. Двусвязный список добавление конец/начало O(1), доступ к произвольному O(n), вставка/удаление O(n), удаление 1-го/последнего  элемента O(1)
19. Очереди реализуются в основном на 2-х связных списках FIFO, LIFO бысрый доступ начало конец, но при добавлении выталкивается элемент с обратной стороны
--------------
методы очередей:
append() доб. в конец/ appendleft() доб. в начало/ pop() удаление справа с возвратом , удалленого элемента, либо ошибка если пустая очередь/popleft() удаление слева/
extend() добавление нескольких в начало insert вставка, remove() удалеие первого найденного, 
clear() очитска очереди, copy создание копии двусвязного списка.


from collection import deque
dq = deque([1,2,3,4,5], maxlen=5) очередь не более 5-и элементов
dq.appendleft(6) добавляем слева

#FIFO
dq.appendleft(10)
calue = dq.pop()
#LIFO
dq.append(55)
value = dq.popleft
__________________
Стек
почти тоже чо и очередь LIFO, но выделлили для удобства, все методы стека O(1)
from collections import deque  или from queue import LifoQueve  такое обычно при многопоточном программировании
stack = deque() или  stack = deque([1,2,3])
stack.append(5)  или stack.appendleft(-1)
value = stack.pop()   stack.popleft()
___________________
Префиксное/перегруженное дерево
ar["dog"] = 1;
ar["to"] = 2;
O(|key|)
____________________
Хэш таблицы хранят ключ значение. при чем ключ получен путем использования хэш функции.





